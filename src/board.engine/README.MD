# Overview
Generate and  manipulate the board state of a game played on a chess board, with each piece on the board knowing where it can move to. This gives enough information to implement the basics rules of a game by validating and executiong moves.

# Introduction 
Initially built purely for chess, it was refactored out (and redesigned along the way) to be a stand-alone component which managed all aspect of the interaction and state of the board.

This includes adding, removing and moving pieces around a board. It is also responsible for both validating and executing moves however it does not explicitly know the individual rules for when and under what circumstances, pieces can be added, removed or moved around, anything specific to an individual game is implemented via code external to the board engine, supporting interfaces such as;

* [`IBoardEntity`][link.IBoardEntity] to define "pieces".
* [`IBoardSetup<TEntity>`][link.IBoardSetup] to define any initial placement of pieces.
* [`IPathGenerator`][link.IPathGenerator] which generate possible moves a piece may take from specified location on the board. eg. a Rook moving straight or a Bishop moving diagonally. See [Paths](#Paths)
* [`IMoveValidationProvider<TEntity>`][link.IMoveValidationProvider] & [`BoardMovePredicate<TEntity>`][link.BoardMovePredicate] uses the moves generated by the [`IPathGenerator`][link.IPathGenerator] implementations, validates them against an actual board, producing a valid [`Paths`][link.Paths]
* [`IBoardAction`][link.IBoardAction] for individual actions upon the board (adding, removing, moving pieces etc.)
* [`IRefreshAllPaths`][link.RefreshAllPaths] which contains any logic required to update all paths on the board. This defaults to a simple loop but chess for example requires some custom processing to handle kings.

Some of these have default implementations availble to either use directly or create custom items for more complex behaviors. See [`chess.engine`][link.ChessEngine] for a complete implementation of this.

Executing behaviors are exposed through a single `Move()` method which supplys the to and from destinations and the type of move (an `int` for simplicity). Seperate containers exist for move type validators and board actions, both come with some standard behaviors and have new ones added to them.

Board state is exposed through the `Board[]` array which returns [`LocatedItem<TEntity>`][link.LocatedItem]. These items contain your original entity (piece] and method to update that entity to a new one, and collection of valid [`Paths`][link.Paths] for that entity. 

A [`Paths`][link.Paths] item contains the set of valid [`BoardMove`][link.BoardMove] items representing the possible moves this entity can make. Based on the move "type" the engine will generate a relevant [`IBoardAction`][link.IBoardAction] and execute it.

After a `Move()` an operation is triggered to refresh the valid [`Paths`][link.Paths] for all entities via [`IRefreshAllPaths`][link.RefreshAllPaths].

With this design, which gives us access to each piece and the moves available to them we can infer which locations are under attack from which pieces. Using this information we can run a game which can;

* validate any input as a valid move by parsing the moving and seeing if it matches one in [`Paths`][link.Paths] collection for the specified piece
* Using [`IBoardAction`][link.IBoardAction], execute the move on the board.
* Using [`IRefreshAllPaths`][link.RefreshAllPaths], trigger the refresh off all [`Paths`][link.Paths]

## Paths
Paths are a core concept of the engine in that a path is defined as a sequence simple moves whereby each following move is only considered if the previous move was validated until either the end of the board is reached or the path is blocked by another piece.

Validations rule might be simple, such as the destination location is empty (for say a typical pawn move] or more complex such as the destination must not be under attack (for a king to move).

In chess this typically means that the move locations are adjacent, the engine does nothing to enforce this and simple uses the order supplied by the path generators.

Default implementations are supplied for basic validations (location is empty etc] and movement actions (basic moves, takes). Custom validations and actions can be added to the relevant providers as required to implement more complex rules and behaviors. See [`chess.engine`][link.ChessEngine] for a complete implementation of this.

[link.IBoardEntity]: /IBoardEntity.cs
[link.IBoardSetup]: /IBoardSetup.cs
[link.IPathGenerator]: /Movement/IPathGenerator.cs
[link.IMoveValidationProvider]: /Movement/MoveValidationProvider.cs
[link.BoardMovePredicate]: /Movement/BoardMovePredicate.cs
[link.Paths]: /Movement/Paths.cs
[link.RefreshAllPaths]: /IRefreshAllPaths.cs
[link.ChessEngine]: ../chess.engine
[link.LocatedItem]: /Board/LocatedItem.cs
[link.BoardMove]: /Movement/BoardMove.cs
[link.IBoardAction]: /Actions/BoardAction.cs
